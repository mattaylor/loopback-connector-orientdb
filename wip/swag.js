// Generated by LiveScript 1.2.0
(function(){
  var YAML, _, fs, Promise, https, env, desc, swag, hosts, apiModel, log, apiPaths, apiResp, modRef, apiGet, apiPost, apiPut, linkRef, apiProp, modSpec, funResp, funSpec, proGet, resRefs, mods, funs, id, ref$, mod, fun, this$ = this;
  YAML = require('js-yaml');
  _ = require('prelude-ls');
  fs = require('fs');
  Promise = require("bluebird");
  https = require('https');
  env = 'acc-dev';
  desc = YAML.safeLoad(fs.readFileSync('./apiDoc.yaml', 'utf8'));
  swag = {
    swagger: '2.0',
    info: {
      title: 'Pharos API',
      description: 'Proteus Digital Health API',
      version: 'v1.0'
    },
    host: env + '.proteus.io',
    basePath: '/v1',
    consumes: ["application/json"],
    produces: ["application/json"],
    security: [{
      accessToken: []
    }],
    securityDefinitions: {
      accessToken: {
        type: "apiKey",
        name: "access",
        'in': "query"
      }
    },
    definitions: {},
    paths: {}
  };
  hosts = {
    dev: '10.163.106.16',
    stage: '10.166.109.17',
    ci: '10.163.111.12',
    prod: '10.224.202.11',
    medDev: '10.229.123.11',
    accDev: '10.229.122.11',
    medInt: '10.229.147.11',
    accInt: '10.229.44.11'
  };
  apiModel = function(dbMod, doc, props){
    var i$, ref$, len$, prop, ref1$, reqs, res;
    doc || (doc = {});
    props == null && (props = {});
    if (desc.models[dbMod.superClass]) {
      doc = import$(clone$(desc.models[dbMod.superClass]), doc);
    }
    for (i$ = 0, len$ = (ref$ = dbMod.properties).length; i$ < len$; ++i$) {
      prop = ref$[i$];
      if ((ref1$ = apiProp(prop, {
        description: doc[prop.name]
      })) != null) {
        props[prop.name] = ref1$;
      }
    }
    props['@rid'] = {
      type: 'string',
      format: '#\\d+:\\d+',
      description: dbMod.name + ' Record Id'
    };
    props['rid'] = {
      type: 'string',
      format: '\\d+:\\d+',
      description: dbMod.name + ' Record Id (shortened)'
    };
    reqs = _.filter(function(it){
      return it != null;
    }, _.map(function(it){
      if (it.name[0] !== '_' && it.mandatory) {
        return it.name;
      }
    }, dbMod.properties));
    res = {
      description: (doc != null ? doc._get : void 8) || (doc != null ? doc._desc : void 8),
      type: 'object',
      properties: props,
      title: dbMod.name
    };
    if (reqs.length) {
      res.required = reqs;
    }
    return res;
  };
  log = function(ob, key){
    key == null && (key = '');
    return console.log(key, ':', ob);
  };
  apiPaths = function(model, op){
    op == null && (op = {});
    if (desc.models[model.name]._get) {
      op.get = apiGet(model);
    }
    if (desc.models[model.name]._put) {
      op.put = apiPut(model);
    }
    if (desc.models[model.name]._post) {
      op.post = apiPost(model);
    }
    return op;
  };
  apiResp = function(model, prefix){
    return {
      200: {
        description: prefix + ' ' + model.name,
        schema: {
          type: 'array',
          items: modRef(model.name)
        }
      }
    };
  };
  modRef = function(name){
    if (name) {
      return {
        $ref: name
      };
    } else {
      return {};
    }
  };
  apiGet = function(model){
    return {
      responses: apiResp(model, 'Fetch'),
      description: desc.models[model.name]._get,
      tags: (desc.models[model.name]._tags || '').split(),
      parameters: [
        {
          'in': 'query',
          name: 'fields',
          type: 'array',
          collectionFormat: 'csv',
          description: 'Fields to return',
          items: {
            type: 'string'
          }
        }, {
          'in': 'path',
          name: 'filter',
          description: 'Query Filter',
          type: 'string'
        }, {
          'in': 'query',
          name: 'options',
          type: 'string',
          description: 'Query Modifiers'
        }, {
          'in': 'query',
          name: 'access',
          type: 'string',
          description: 'Access Token'
        }
      ]
    };
  };
  apiPost = function(model){
    return {
      responses: apiResp(model, 'Create'),
      tags: (desc.models[model.name]._tags || '').split(),
      parameters: [
        {
          'in': 'body',
          name: model.name,
          description: 'New ' + model.name + ' parameters',
          schema: modRef(model.name)
        }, {
          'in': 'query',
          name: 'access',
          description: 'Access Token',
          type: 'string'
        }
      ],
      description: 'Create ' + desc.models[model.name]._post
    };
  };
  apiPut = function(model){
    return {
      responses: apiResp(model, 'Update'),
      tags: (desc.models[model.name]._tags || '').split(),
      parameters: [
        {
          'in': 'body',
          name: 'merge',
          description: 'Updated ' + model.name + ' parameters',
          schema: {
            type: 'object'
          }
        }, {
          'in': 'path',
          name: 'filter',
          description: 'Record Id',
          type: 'string'
        }, {
          'in': 'query',
          name: 'access',
          description: 'access token',
          type: 'string'
        }
      ],
      description: 'Update ' + desc.models[model.name]._put
    };
  };
  linkRef = function(name){
    return {
      anyOf: [
        {
          type: "string",
          description: name + ' Record Id',
          format: "#\\d+:\\d+"
        }, {
          $ref: name
        }
      ]
    };
  };
  apiProp = function(oprop, jprop){
    var otype, olink;
    jprop == null && (jprop = {});
    if (oprop.name[0] === '_') {
      return;
    }
    if (oprop.name === 'dirty') {
      return;
    }
    otype = oprop.type.toLowerCase();
    olink = oprop.linkedClass;
    if (olink) {
      if (olink === 'OUser') {
        olink = 'user';
      }
      if (!desc.models[olink]) {
        return;
      }
    }
    switch (otype) {
    case 'linklist':
      jprop = {
        type: 'array',
        items: linkRef(olink)
      };
      break;
    case 'linkset':
      jprop = {
        type: 'array',
        items: linkRef(olink)
      };
      break;
    case 'linkmap':
      jprop = {
        type: 'object'
      };
      break;
    case 'link':
      jprop = linkRef(olink);
      break;
    case 'embeddedlist':
      jprop = {
        type: 'array',
        items: {
          type: 'string'
        }
      };
      break;
    case 'embeddedset':
      jprop = {
        type: 'array',
        items: {
          type: 'string'
        }
      };
      break;
    case 'embeddedmap':
      jprop.type = 'object';
      break;
    case 'datetime':
      jprop = {
        type: 'string',
        format: 'datetime'
      };
      break;
    case 'long':
      jprop.type = 'integer';
      break;
    case 'float':
      jprop.type = 'number';
      break;
    case 'double':
      jprop.type = 'number';
      break;
    default:
      jprop.type = otype;
    }
    return jprop;
  };
  modSpec = function(mod, spec){
    var doc, paths;
    doc = desc.models[mod.name] || {};
    if (!doc._desc && !doc._get) {
      return spec;
    }
    spec.definitions[mod.name] = apiModel(mod, doc);
    if (!doc._get && !doc._post && !doc._put) {
      return spec;
    }
    paths = apiPaths(mod);
    if (!deepEq$(paths, {}, '===')) {
      spec.paths["/" + mod.name + "/{filter}"] = paths;
    }
    return spec;
  };
  funResp = function(doc){
    var name, prop;
    if (!doc) {
      return;
    }
    if (typeof doc === 'string') {
      return {
        type: 'string',
        description: doc
      };
    }
    if (doc.length) {
      return {
        type: 'array',
        items: funResp(doc[0])
      };
    }
    for (name in doc) {
      prop = doc[name];
      if (prop) {
        doc[name] = funResp(prop);
      } else {
        doc[name] = {
          $ref: name
        };
      }
    }
    return doc;
  };
  funSpec = function(func, spec, params){
    var doc, matches, e, funApi, path, i$, ref$, len$, param;
    params == null && (params = []);
    doc = desc.funcs[func.name];
    console.log('FUNCT:', func);
    try {
      matches = func.code.match(/\*\*\s([^/]*)\s\*\*/);
      if (matches != null && matches[1]) {
        import$(doc, YAML.load(matches[1]));
      }
    } catch (e$) {
      e = e$;
      console.log('YAML:', e);
    }
    if (!(doc != null && doc._desc)) {
      return spec;
    }
    funApi = {
      description: doc._desc,
      responses: {
        200: {
          description: doc._desc,
          schema: {
            type: 'object',
            properties: funResp(doc._out)
          }
        }
      }
    };
    if (doc._tags) {
      funApi.tags = funApi.tags = doc._tags.split();
    } else {
      funApi.tags = ['Misc Functions'];
    }
    path = "/!" + func.name;
    if (func.parameters) {
      for (i$ = 0, len$ = (ref$ = func.parameters).length; i$ < len$; ++i$) {
        param = ref$[i$];
        path += "/{" + param + "}";
        params.push({
          'in': 'path',
          name: param,
          type: 'string',
          description: doc[param]
        });
      }
    }
    if (doc._inp) {
      params.push({
        'in': 'body',
        name: 'body',
        schema: funResp(doc._inp)
      });
    }
    if (params.length) {
      funApi.parameters = params;
    }
    if (func.idempotent) {
      spec.paths[path] = {
        get: funApi
      };
    } else {
      spec.paths[path] = {
        post: funApi
      };
    }
    return spec;
  };
  proGet = function(path, call, body){
    body == null && (body = '');
    return new Promise(function(resolve, reject){
      var access;
      console.log('fetching ' + env + ' ' + path);
      access = 'FHBNSmbK716fR1GsCWZBEV4+ke4CS38k90j8CMX0qghJDa2wuCbQSfk3g0dOVbcFbeILfgslaZR3oWwXs9n7Ww==';
      return https.get('https://' + env + '.proteus.io/v1/' + path + '?access=' + access, function(res){
        res.on('error', function(e){
          console.log(path + ' error ', e.message);
          return reject(e);
        });
        res.on('data', function(chunk){
          return body += chunk;
        });
        return res.on('end', function(oBody){
          oBody == null && (oBody = JSON.parse(body));
          if (oBody.result) {
            if (oBody.result.length === 1) {
              return resolve(oBody.result[0]);
            } else {
              return resolve(oBody.result);
            }
          } else {
            return resolve(oBody);
          }
        });
      });
    });
  };
  resRefs = function(spec){
    var orig, modId, ref$, model, proId, ref1$, prop, ref2$, ref3$;
    orig = import$({}, spec);
    for (modId in ref$ = orig.definitions) {
      model = ref$[modId];
      for (proId in ref1$ = model.properties) {
        prop = ref1$[proId];
        if ((ref2$ = prop.anyOf) != null && ((ref3$ = ref2$[1]) != null && ref3$.$ref)) {
          console.log(("resolving " + modId + " . " + proId + " as [") + prop.anyOf[1].$ref + "]");
          spec.definitions[modId].properties[proId].anyOf[1] = JSON.parse(JSON.stringify(orig.definitions[prop.anyOf[1].$ref]));
        }
      }
    }
    return spec;
  };
  mods = [];
  funs = [];
  for (id in ref$ = desc.models) {
    mod = ref$[id];
    mods.push(proGet('@' + id));
  }
  for (id in ref$ = desc.funcs) {
    fun = ref$[id];
    funs.push(proGet('OFunction/name=' + id));
  }
  Promise.all(mods).then(function(mods){
    return Promise.all(funs).then(function(funs){
      var spec, i$, len$, fun, ref$, mod;
      spec = swag;
      for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
        fun = funs[i$];
        spec = funSpec(fun, spec);
      }
      for (i$ = 0, len$ = (ref$ = mods).length; i$ < len$; ++i$) {
        mod = ref$[i$];
        spec = modSpec(mod, spec);
      }
      fs.writeFileSync("./apiSwag.yaml", YAML.safeDump(spec, {
        skipInvalid: true
      }));
      return fs.writeFileSync("./apiSwag.json", JSON.stringify(spec));
    });
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
