// Generated by CoffeeScript 1.9.0
(function() {
  var Promise, YAML, doc, fs, fun, funs, host, https, id, linkRef, log, loopMod, loopProp, mod, mods, proGet, writeMod, _, _ref, _ref1;

  YAML = require('js-yaml');

  _ = require('lodash');

  fs = require('fs');

  Promise = require("bluebird");

  https = require('https');

  host = 'YOUR HOST HERE';

  doc = YAML.safeLoad(fs.readFileSync('./apiDoc.yaml', 'utf8'));

  loopMod = function(dbMod, lbMod) {
    var myDoc, prop, _i, _len, _ref;
    if (lbMod == null) {
      lbMod = {};
    }
    log('GOT MOD:' + dbMod.name);
    if (doc.models[dbMod.superClass]) {
      _(myDoc).defaults(doc.models[dbMod.superclass]);
    }
    myDoc = doc.models[dbMod.name];
    lbMod = {
      name: dbMod.name,
      base: dbMod.superClass,
      idInjection: false,
      strict: false,
      relations: {},
      scopes: {}
    };
    lbMod.description = myDoc._desc;
    lbMod.properties = {
      '@rid': {
        type: 'string',
        format: '#\\d+:\\d+',
        description: dbMod.name + ' Record Id',
        id: true
      }
    };
    _ref = dbMod.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      prop = _ref[_i];
      if (myDoc[prop.name]) {
        lbMod.properties[prop.name] = loopProp(prop);
      }
    }
    return lbMod;
  };

  log = function(ob, key) {
    if (key == null) {
      key = '';
    }
    return console.log(key, ':', ob);
  };

  linkRef = function(name) {
    return {
      anyOf: [
        {
          type: "string",
          description: name + ' Record Id',
          format: "#\\d+:\\d+"
        }, {
          $ref: name
        }
      ]
    };
  };

  loopProp = function(dbProp, lbProp) {
    var dbLink, dbType;
    if (lbProp == null) {
      lbProp = {};
    }
    log('got prop:' + dbProp.name);
    if (dbProp.name[0] === '_') {
      return;
    }
    dbType = dbProp.type.toLowerCase();
    dbLink = dbProp.linkedClass;
    if (dbLink) {
      if (dbLink === 'OUser') {
        dbLink = 'user';
      }
      if (!doc.models[dbLink]) {
        return;
      }
    }
    switch (dbType) {
      case 'linklist':
        lbProp = {
          type: 'array',
          items: linkRef(dbLink)
        };
        break;
      case 'linkset':
        lbProp = {
          type: 'array',
          items: linkRef(dbLink)
        };
        break;
      case 'linkmap':
        lbProp = {
          type: 'object'
        };
        break;
      case 'link':
        lbProp = linkRef(dbLink);
        break;
      case 'embeddedlist':
        lbProp = {
          type: 'array',
          items: {
            type: 'string'
          }
        };
        break;
      case 'embeddedset':
        lbProp = {
          type: 'array',
          items: {
            type: 'string'
          }
        };
        break;
      case 'embeddedmap':
        lbProp.type = 'object';
        break;
      case 'datetime':
        lbProp = {
          type: 'string',
          format: 'datetime'
        };
        break;
      case 'long':
        lbProp.type = 'integer';
        break;
      case 'float':
        lbProp.type = 'number';
        break;
      case 'double':
        lbProp.type = 'number';
        break;
      default:
        lbProp.type = dbType;
    }
    return lbProp;
  };


  /*
  funResp = (doc) ->
  	if !doc then return
  	if typeof doc == 'string' then return type:'string', description:doc
  	if doc.length then return type:'array', items: funResp doc[0]
  	for name, prop of doc then if prop then doc[name] = funResp prop else doc[name] = $ref: name
  	doc
  
  funSpec = (func, spec, params=[]) ->
  	doc = desc.funcs[func.name]
  	console.log 'FUNCT:', func
  	try
  		matches = func.code.match /\*\*\s([^/]*)\s\*\* /
  		if matches?[1] then doc <<< YAML.load matches[1]
  	catch
  		console.log 'YAML:', e
  	if !doc?._desc then return spec
  	funApi = description:doc._desc,responses:200:description:doc._desc,schema:type:'object',properties:funResp doc._out
  	if doc._tags then funApi.tags = funApi.tags = doc._tags.split! else funApi.tags = ['Misc Functions']
  	path = "/!"+func.name
  	if func.parameters then for param in func.parameters
  		path += "/{#param}"
  		params.push in:'path', name:param, type:'string', description:doc[param]
  	if doc._inp then params.push in:'body', name:'body', schema: funResp doc._inp
  	if params.length then funApi.parameters = params
  	if func.idempotent then spec.paths[path]=get:funApi else spec.paths[path]=post:funApi
  	spec
   */

  proGet = function(path, call, body) {
    if (body == null) {
      body = '';
    }
    return new Promise(function(resolve, reject) {
      console.log('fetching ' + env + ' ' + path);
      return https.get('https://' + host + '/' + path + '?access=' + access, function(res) {
        res.on('error', function(e) {
          console.log(path + ' error ', e.message);
          return reject(e);
        });
        res.on('data', function(chunk) {
          return body += chunk;
        });
        return res.on('end', function(oBody) {
          if (oBody == null) {
            oBody = JSON.parse(body);
          }
          if (oBody.result) {
            if (oBody.result.length === 1) {
              return resolve(oBody.result[0]);
            } else {
              return resolve(oBody.result);
            }
          } else {
            return resolve(oBody);
          }
        });
      });
    });
  };

  mods = [];

  funs = [];

  writeMod = function(model) {
    return fs.writeFileSync("./models/" + model.name + ".json", JSON.stringify(model));
  };

  _ref = doc.models;
  for (id in _ref) {
    mod = _ref[id];
    mods.push(proGet('@' + id));
  }

  _ref1 = doc.funcs;
  for (id in _ref1) {
    fun = _ref1[id];
    funs.push(proGet('OFunction/name=' + id));
  }

  Promise.all(mods).then(function(mods) {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = mods.length; _i < _len; _i++) {
      mod = mods[_i];
      _results.push(writeMod(loopMod(mod, doc)));
    }
    return _results;
  });

}).call(this);
